local Library = loadstring(Game:HttpGet("https://raw.githubusercontent.com/bloodball/-back-ups-for-libs/main/wizard"))()

local PhantomForcesWindow = Library:NewWindow("Felixx shoot people off a map")

local KillingCheats = PhantomForcesWindow:NewSection("silent aim 🎯")

KillingCheats:CreateButton("cannon Shootty💣", function()
local localPlayer = game:GetService("Players").LocalPlayer
local character = localPlayer.Character
local remote = character.CannonShotty.RemoteBridge

local isActive = false
local shootingCoroutine = nil

local function getClosestPlayer()
    local closestPlayer = nil
    local closestDistance = math.huge

    for _, player in pairs(game:GetService("Players"):GetPlayers()) do
        if player ~= localPlayer and player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
            local distance = (player.Character.HumanoidRootPart.Position - character.HumanoidRootPart.Position).magnitude
            if distance < closestDistance then
                closestDistance = distance
                closestPlayer = player
            end
        end
    end

    return closestPlayer
end

local function shoot()
    while isActive do
        local targetPlayer = getClosestPlayer()

        if targetPlayer and targetPlayer.Character and targetPlayer.Character:FindFirstChild("HumanoidRootPart") then
            local targetPosition = targetPlayer.Character.HumanoidRootPart.Position
            local args = {
                [1] = targetPosition
            }

            remote:FireServer(unpack(args))
        end

        wait(1)
    end
end

local function toggleShooting()
    isActive = not isActive -- Alternar el estado

    if isActive then
        shootingCoroutine = coroutine.create(shoot)
        coroutine.resume(shootingCoroutine)
    else
        if shootingCoroutine then
            -- Detener el disparo
            isActive = false
        end
    end
end

toggleShooting() -- Llamar a la función para activar o desactivar el disparo
end)

KillingCheats:CreateButton("Normal Shotgun", function()
local localPlayer = game:GetService("Players").LocalPlayer
local character = localPlayer.Character
local remote = character.Shotgun.RemoteBridge

local isActive = false
local shootingCoroutine = nil

local function getClosestPlayer()
    local closestPlayer = nil
    local closestDistance = math.huge

    for _, player in pairs(game:GetService("Players"):GetPlayers()) do
        if player ~= localPlayer and player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
            local distance = (player.Character.HumanoidRootPart.Position - character.HumanoidRootPart.Position).magnitude
            if distance < closestDistance then
                closestDistance = distance
                closestPlayer = player
            end
        end
    end

    return closestPlayer
end

local function shoot()
    while isActive do
        local targetPlayer = getClosestPlayer()

        if targetPlayer and targetPlayer.Character and targetPlayer.Character:FindFirstChild("HumanoidRootPart") then
            local targetPosition = targetPlayer.Character.HumanoidRootPart.Position
            local args = {
                [1] = targetPosition
            }

            remote:FireServer(unpack(args))
        end

        wait(1)
    end
end

local function toggleShooting()
    isActive = not isActive -- Alternar el estado

    if isActive then
        shootingCoroutine = coroutine.create(shoot)
        coroutine.resume(shootingCoroutine)
    else
        if shootingCoroutine then
            -- Detener el disparo
            isActive = false
        end
    end
end

toggleShooting() -- Llamar a la función para activar o desactivar el disparo
end)

KillingCheats:CreateButton("Explosive Shotty💥", function()
local localPlayer = game:GetService("Players").LocalPlayer
local character = localPlayer.Character
local remote = character.ExplosiveShotty.RemoteBridge

local isActive = false
local shootingCoroutine = nil

local function getClosestPlayer()
    local closestPlayer = nil
    local closestDistance = math.huge

    for _, player in pairs(game:GetService("Players"):GetPlayers()) do
        if player ~= localPlayer and player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
            local distance = (player.Character.HumanoidRootPart.Position - character.HumanoidRootPart.Position).magnitude
            if distance < closestDistance then
                closestDistance = distance
                closestPlayer = player
            end
        end
    end

    return closestPlayer
end

local function shoot()
    while isActive do
        local targetPlayer = getClosestPlayer()

        if targetPlayer and targetPlayer.Character and targetPlayer.Character:FindFirstChild("HumanoidRootPart") then
            local targetPosition = targetPlayer.Character.HumanoidRootPart.Position
            local args = {
                [1] = targetPosition
            }

            remote:FireServer(unpack(args))
        end

        wait(1)
    end
end

local function toggleShooting()
    isActive = not isActive -- Alternar el estado

    if isActive then
        shootingCoroutine = coroutine.create(shoot)
        coroutine.resume(shootingCoroutine)
    else
        if shootingCoroutine then
            -- Detener el disparo
            isActive = false
        end
    end
end

toggleShooting() -- Llamar a la función para activar o desactivar el disparo
end)

KillingCheats:CreateButton("Dual shotty", function()
local localPlayer = game:GetService("Players").LocalPlayer
local character = localPlayer.Character
local remote = character.DualShotty.RemoteBridge

local isActive = false
local shootingCoroutine = nil

local function getClosestPlayer()
    local closestPlayer = nil
    local closestDistance = math.huge

    for _, player in pairs(game:GetService("Players"):GetPlayers()) do
        if player ~= localPlayer and player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
            local distance = (player.Character.HumanoidRootPart.Position - character.HumanoidRootPart.Position).magnitude
            if distance < closestDistance then
                closestDistance = distance
                closestPlayer = player
            end
        end
    end

    return closestPlayer
end

local function shoot()
    while isActive do
        local targetPlayer = getClosestPlayer()

        if targetPlayer and targetPlayer.Character and targetPlayer.Character:FindFirstChild("HumanoidRootPart") then
            local targetPosition = targetPlayer.Character.HumanoidRootPart.Position
            local args = {
                [1] = targetPosition
            }

            remote:FireServer(unpack(args))
        end

        wait(1)
    end
end

local function toggleShooting()
    isActive = not isActive -- Alternar el estado

    if isActive then
        shootingCoroutine = coroutine.create(shoot)
        coroutine.resume(shootingCoroutine)
    else
        if shootingCoroutine then
            -- Detener el disparo
            isActive = false
        end
    end
end

toggleShooting() -- Llamar a la función para activar o desactivar el disparo
end)

local KillingCheats = PhantomForcesWindow:NewSection("Misc")

KillingCheats:CreateButton("Anti ragdoll", function()
loadstring(game:HttpGet("https://rawscripts.net/raw/Shoot-People-Off-A-Map-Simulator-nti-kb-8005"))()
end)

local tspeed = 1
local minSpeed = 1
local maxSpeed = 100
local hb = game:GetService("RunService").Heartbeat
local tpwalking = true
local player = game:GetService("Players")
local lplr = player.LocalPlayer
local hum

local function isNumber(str)
    return tonumber(str) ~= nil or str == 'inf'
end

local function adjustSpeed(newSpeed)
    if isNumber(newSpeed) then
        local speedValue = tonumber(newSpeed)
        if speedValue < minSpeed then
            tspeed = minSpeed
        elseif speedValue > maxSpeed then
            tspeed = maxSpeed
        else
            tspeed = speedValue
        end
    end
end

local function setupCharacter()
    local chr = lplr.Character or lplr.CharacterAdded:Wait()
    hum = chr:WaitForChild("Humanoid")

    -- Reemplazo de input field por KillingCheats:CreateTextbox
    KillingCheats:CreateTextbox("Speed", function(text)
        adjustSpeed(text)
    end)

    -- Bucle de movimiento
    spawn(function() -- Usar spawn para permitir que el bucle funcione en paralelo
        while tpwalking and hb:Wait() and chr and hum and hum.Parent do
            if hum.MoveDirection.Magnitude > 0 then
                local adjustedSpeed = tspeed * 0.2  -- Aumenta el multiplicador para velocidad mínima
                chr:TranslateBy(hum.MoveDirection * adjustedSpeed)
            end
        end
    end)
end

-- Configurar el personaje al iniciar
setupCharacter()

-- Conectar la función al evento CharacterAdded
lplr.CharacterAdded:Connect(function()
    -- Esperar que el nuevo personaje se configure antes de ejecutar
    wait(0.5)  -- Espera un breve momento para asegurar que el personaje se cargue
    setupCharacter()
end)
